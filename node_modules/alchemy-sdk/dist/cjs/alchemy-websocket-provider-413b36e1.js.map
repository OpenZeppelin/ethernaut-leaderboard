{"version":3,"file":"alchemy-websocket-provider-413b36e1.js","sources":["../../src/internal/websocket-backfiller.ts","../../src/api/alchemy-websocket-provider.ts"],"sourcesContent":["import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n"],"names":["fromHex","toHex","WebSocketProvider","AlchemyProvider","VERSION","SturdyWebSocket","EthersNetwork","__awaiter","noop","CustomNetworks","getNetworkFromEthers","isAlchemyEvent","verifyAlchemyEventName","EthersEvent","getAlchemyEventTag","ALCHEMY_EVENT_TYPES","DEFAULT_ALCHEMY_API_KEY","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","AlchemySubscription","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","BigNumber"],"mappings":"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"}